# -*- coding: UTF-8 -*-
#
# generated by wxGlade 0.8.0b3 on Tue Jan 30 13:49:27 2018
#

import sys
import os
import wx
import time
import numpy as np
from numpy.matlib import repmat
import numpy.ma as ma
import scipy.io
import netCDF4 as netcdf
import matplotlib.pyplot as plt
from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas
from matplotlib.figure import Figure
from matplotlib import colors

from matplotlib import animation
from matplotlib.widgets  import RectangleSelector
from Croco import Croco
# from CrocoXarray import Croco
from myplot import plotCurv, mypcolor
import numpy.ma as ma


wildcard = "Netcdf Files (*.nc)|*.nc"
figsize = [6,5]


########################################################################

class SectionFrame(wx.Frame):

    def __init__(self,typSection="XY",croco=None):

        """Class to plot longitude/latitude section"""

        wx.Frame.__init__(self, None, wx.ID_ANY, title='Section')

        self.typSection=typSection
        self.croco = croco
        self.panel = wx.Panel(self, wx.ID_ANY)

        self.figure = Figure()
        self.axes = self.figure.add_axes([0,0,1,1])
        self.canvas = FigureCanvas(self.panel, -1, self.figure)
        self.canvas.mpl_connect('button_press_event', self.onFigureClick)
        self.canvas.mpl_connect('button_release_event', self.onFigureRelease)

        self.AnimationBtn = wx.Button(self.panel, wx.ID_ANY, "Animation")
        self.AnimationBtn.Bind(wx.EVT_BUTTON, self.onAnimationBtn)
        self.startTimeTxt = wx.TextCtrl(self.panel, wx.ID_ANY, "1", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.startTimeTxt.Bind(wx.EVT_TEXT_ENTER, self.onstartTimeTxt)
        self.endTimeTxt = wx.TextCtrl(self.panel, wx.ID_ANY, "1", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.endTimeTxt.Bind(wx.EVT_TEXT_ENTER, self.onendTimeTxt)
        self.ZoomInBtn = wx.Button(self.panel, wx.ID_ANY, "Zoom In")
        self.ZoomInBtn.Bind(wx.EVT_BUTTON, self.onZoomInBtn)
        self.ZoomOutBtn = wx.Button(self.panel, wx.ID_ANY, "Zoom Out")
        self.ZoomOutBtn.Bind(wx.EVT_BUTTON, self.onZoomOutBtn)
        self.PrintBtn = wx.Button(self.panel, wx.ID_ANY, "Print")
        self.PrintBtn.Bind(wx.EVT_BUTTON, self.onPrintBtn)
        
        self.ResetColorBtn = wx.Button(self.panel, wx.ID_ANY, "Reset Color")
        self.ResetColorBtn.Bind(wx.EVT_BUTTON, self.onResetColorBtn)
        self.MinColorTxt = wx.TextCtrl(self.panel, wx.ID_ANY, "Min Color", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.MinColorTxt.Bind(wx.EVT_TEXT_ENTER, self.onMinColorTxt)
        self.MaxColorTxt = wx.TextCtrl(self.panel, wx.ID_ANY, "Max Color", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.MaxColorTxt.Bind(wx.EVT_TEXT_ENTER, self.onMaxColorTxt)

        self.__do_layout()

    def __do_layout(self):

        topSizer        = wx.BoxSizer(wx.VERTICAL)
        canvasSizer     = wx.BoxSizer(wx.VERTICAL)
        buttonsSizer    = wx.BoxSizer(wx.HORIZONTAL)
        colorSizer      = wx.BoxSizer(wx.HORIZONTAL)


        canvasSizer.Add(self.canvas, 0, wx.ALL, 5)
        buttonsSizer.Add(self.AnimationBtn,0, wx.ALL, 5)
        buttonsSizer.Add(self.startTimeTxt,1, wx.ALL, 5)
        buttonsSizer.Add(self.endTimeTxt,1, wx.ALL, 5)
        buttonsSizer.Add(self.ZoomInBtn,0, wx.ALL, 5)
        buttonsSizer.Add(self.ZoomOutBtn,0, wx.ALL, 5)
        buttonsSizer.Add(self.PrintBtn,0, wx.ALL, 5)
        colorSizer.Add(self.ResetColorBtn, 0, wx.ALL, 5)
        colorSizer.Add(self.MinColorTxt, 0, wx.ALL, 5)
        colorSizer.Add(self.MaxColorTxt, 0, wx.ALL, 5)

        topSizer.Add(canvasSizer, 0, wx.CENTER)
        topSizer.Add(buttonsSizer, 0, wx.ALL|wx.EXPAND, 5)
        topSizer.Add(colorSizer, 0, wx.ALL|wx.EXPAND, 5)

        self.panel.SetSizer(topSizer)
        topSizer.Fit(self)

        self.Layout()

    def onFigureClick(self,event):
        self.xPress, self.yPress = event.xdata, event.ydata

    def onFigureRelease(self,event):
        self.xRelease, self.yRelease = event.xdata, event.ydata

    def rect_select_callback(self, eclick, erelease):
        ''' Function for ZoomIn button'''
        self.xPress, self.yPress = eclick.xdata, eclick.ydata
        self.xRelease, self.yRelease = erelease.xdata, erelease.ydata
        self.xlim = [min(self.xPress,self.xRelease),max(self.xPress,self.xRelease)]
        self.ylim = [ min(self.yPress,self.yRelease),max(self.yPress,self.yRelease)]
        self.drawz(setlim=False)

    def onAnimationBtn(self,event):
        ''' Function when Animation button is pressed'''
        printDir = self.croco.path_script+"/Figures_" + self.croco.get_run_name()+"/"
        if not os.path.isdir(printDir):
                os.mkdir(printDir)
        filename = printDir+self.title + ".mp4"
        os.system('rm -rf '+filename)
        self.clim = [np.min(self.variableZ),np.max(self.variableZ)]
        save_count = self.endTimeIndex - self.startTimeIndex + 1
        anim = animation.FuncAnimation(self.figure, self.animate, \
                   frames = range(self.startTimeIndex,self.endTimeIndex+1), repeat=False, \
                   blit = False, save_count=save_count)
        self.canvas.draw()
        anim.save(filename)
        
    def animate( self, i):
        ''' Function done at each step of the animation'''
        self.timeIndex = i
        self.updateVariableZ(timeIndex=i, setlim=False)

    def onstartTimeTxt(self,event):
        self.startTime = float(self.startTimeTxt.GetValue())
        self.startTimeIndex = min( range( len(self.croco.times[:]) ), key=lambda j:abs(self.startTime-self.croco.times[j]))
        self.startTimeTxt.SetValue(str(self.croco.times[self.startTimeIndex]))

    def onendTimeTxt(self,event):
        self.endTime = float(self.endTimeTxt.GetValue())
        self.endTimeIndex = min( range( len(self.croco.times[:]) ), key=lambda j:abs(self.endTime-self.croco.times[j]))
        self.endTimeTxt.SetValue(str(self.croco.times[self.endTimeIndex]))

    def onZoomInBtn(self,event):       
        self.figure.RS.set_active(True)

    def onZoomOutBtn(self,event):
        self.xlim = [np.min(self.x),np.max(self.x)]
        self.ylim = [np.min(self.y),np.max(self.y)]
        self.drawz(setlim=False)

    def onPrintBtn(self,event):
        ''' Save the plot in a file croco_visu/Figures_.../title.png '''
        printDir = self.croco.path_script+"/Figures_" + self.croco.get_run_name()+"/"
        if not os.path.isdir(printDir):
                os.mkdir(printDir)
        filename = printDir+self.title + ".png"
        self.figure.savefig(filename, dpi=self.figure.dpi)

    def onResetColorBtn(self,event):
        self.clim = [np.min(self.variableZ),np.max(self.variableZ)]
        self.MinColorTxt.SetValue('%.2E' % self.clim[0])
        self.MaxColorTxt.SetValue('%.2E' % self.clim[1])
        self.drawz(setlim=False)

    def onMinColorTxt(self,event):
        self.clim[0] = float(self.MinColorTxt.GetValue())
        self.drawz(setlim=False)

    def onMaxColorTxt(self,event):
        self.clim[1] = float(self.MaxColorTxt.GetValue())
        self.drawz(setlim=False)

    def updateVariableZ(self, timeIndex=None, setlim=True):
        ''' Fill self.variableZ with the new data according modified parameters for the section '''

        # Variable in croco file
        if self.variableName in self.croco.ListOfVariables: 
            if timeIndex is None:
                timeIndex = self.timeIndex
            if self.typSection=="YZ":
                indices="["+str(timeIndex)+",:,:,"+str(self.latlonIndex)+"]"
            else:        
                indices="["+str(timeIndex)+",:,"+str(self.latlonIndex)+",:]"
            self.variableZ = self.croco.read_nc(self.variableName, indices= indices)

        # Derived variable
        elif self.variableName in self.croco.ListOfDerived:
            # if self.variableName ==  'pv':
            if 'pv' in self.variableName:
                pv = self.croco.get_pv(timeIndex, minlev=0, maxlev=self.croco.crocoGrid.N-1,typ=self.variableName)
                if self.typSection=="YZ":
                    self.variableZ = pv[:,:,self.latlonIndex]
                else:        
                    self.variableZ = pv[:,self.latlonIndex,:]
        # Plot the section variable           
        self.time = self.croco.times[timeIndex]
        self.drawz(setlim=setlim)

    def drawz(self, setlim=True):
        ''' draw the current self.variableZ variable '''

        self.figure.clf()
        # Prepare canvas to receive the mouse click 
        self.canvas.mpl_connect('button_press_event', self.onFigureClick)
        self.canvas.mpl_connect('button_release_event', self.onFigureRelease)

        # Mask Nan values
        variableZ = ma.masked_invalid(self.variableZ)

        # Calculate default parameters of the plot if necessary
        if setlim:
            self.clim = [np.min(variableZ),np.max(variableZ)]
            self.mincolor = np.min(variableZ)
            self.MinColorTxt.SetValue('%.2E' % self.mincolor)
            self.maxcolor = np.max(variableZ)
            self.MaxColorTxt.SetValue('%.2E' % self.maxcolor)
            self.xlim = [np.min(self.x),np.max(self.x)]
            self.ylim = [np.min(self.y),np.max(self.y)]

        # Plot variableZ
        self.title = "{:s}, {:s}={:4.1f}, Time={:4.1f}".format(self.variableName,self.section,self.latlon,self.time)
        mypcolor(self,self.x,self.y,variableZ,\
                      title=self.title,\
                      xlabel=self.xlabel,\
                      ylabel='Depth',\
                      xlim=self.xlim,\
                      ylim=self.ylim,\
                      clim=self.clim)

        self.canvas.draw()
        self.canvas.Refresh()
        self.Show()


########################################################################

class ProfileFrame(wx.Frame):

    def __init__(self, croco):

        """ Class for Time Series and Vertical Porfile"""

        wx.Frame.__init__(self, None, wx.ID_ANY, title='Profile')

        self.croco = croco
        self.panel = wx.Panel(self, wx.ID_ANY)

        self.figure = Figure()
        # self.axes = self.figure.add_axes([0.1,0.1,0.9,0.9])
        self.canvas = FigureCanvas(self.panel, -1, self.figure)

        self.ZoomInBtn = wx.Button(self.panel, wx.ID_ANY, "Zoom In")
        self.ZoomInBtn.Bind(wx.EVT_BUTTON, self.onZoomInBtn)
        self.ZoomOutBtn = wx.Button(self.panel, wx.ID_ANY, "Zoom Out")
        self.ZoomOutBtn.Bind(wx.EVT_BUTTON, self.onZoomOutBtn)
        self.PrintBtn = wx.Button(self.panel, wx.ID_ANY, "Print")
        self.PrintBtn.Bind(wx.EVT_BUTTON, self.onPrintBtn)


        self.__do_layout()

    def __do_layout(self):

        topSizer        = wx.BoxSizer(wx.VERTICAL)
        canvasSizer     = wx.BoxSizer(wx.VERTICAL)
        buttonsSizer    = wx.BoxSizer(wx.HORIZONTAL)


        canvasSizer.Add(self.canvas, 0, wx.ALL, 5)
        buttonsSizer.Add(self.ZoomInBtn,0, wx.ALL, 5)
        buttonsSizer.Add(self.ZoomOutBtn,0, wx.ALL, 5)
        buttonsSizer.Add(self.PrintBtn,0, wx.ALL, 5)

        topSizer.Add(canvasSizer, 0, wx.CENTER)
        topSizer.Add(buttonsSizer, 0, wx.ALL|wx.EXPAND, 5)

        self.panel.SetSizer(topSizer)
        topSizer.Fit(self)

        # self.Layout()

    def onFigureClick(self,event):
        self.xPress, self.yPress = event.xdata, event.ydata

    def onFigureRelease(self,event):
        self.xRelease, self.yRelease = event.xdata, event.ydata

    def rect_select_callback(self, eclick, erelease):
        ''' Function for selecting rectangle when zoom in '''
        self.xPress, self.yPress = eclick.xdata, eclick.ydata
        self.xRelease, self.yRelease = erelease.xdata, erelease.ydata
        self.xlim = [min(self.xPress,self.xRelease),max(self.xPress,self.xRelease)]
        self.ylim = [ min(self.yPress,self.yRelease),max(self.yPress,self.yRelease)]
        self.drawCurv(setlim=False)

    def onZoomInBtn(self,event):
        self.figure.RS.set_active(True)

    def onZoomOutBtn(self,event):
        self.drawCurv()

    def onPrintBtn(self,event):
        ''' Save plot in croco_visu/Figures_.../title.png '''
        printDir = self.croco.path_script+"/Figures_" + self.croco.get_run_name()+"/"
        if not os.path.isdir(printDir):
                os.mkdir(printDir)
        filename = printDir+self.title + ".png"
        self.figure.savefig(filename, dpi=self.figure.dpi)

    def drawCurv(self,profile=None,z=None,title=None,ylabel=None,setlim=True):
        ''' draw the time series or vertical profile curve '''
        if profile is not None:
            self.profile = profile
            self.z = z
            self.title = title
            self.ylabel = ylabel

        # Prepare the canvas to receive mouse click event
        self.canvas.mpl_connect('button_press_event', self.onFigureClick)
        self.canvas.mpl_connect('button_release_event', self.onFigureRelease)

        # Set default parameters of the plot if needed
        if setlim:
                self.xlim=None
                self.ylim=None

        # Draw the curve
        if self.z is not None:
            plotCurv(self,x=self.profile,y=self.z,title=self.title,ylabel=self.ylabel,
                     xlim=self.xlim, ylim=self.ylim)
        else:
            plotCurv(self,x=self.profile,title=self.title,
                     xlim=self.xlim, ylim=self.ylim)
        self.canvas.draw()
        self.canvas.Refresh()
        self.Show()

########################################################################

class CrocoGui(wx.Frame):

    ''' Class for the main window (ie horizontal slice) '''

    def __init__(self):

        wx.Frame.__init__(self, None, wx.ID_ANY, title='My Form')

        self.Panel = wx.Panel(self, wx.ID_ANY)

        self.OpenFileBtn = wx.Button(self.Panel, wx.ID_ANY, "Open History File ...")
        self.OpenFileBtn.Bind(wx.EVT_BUTTON, self.onOpenFile)
        self.OpenFileTxt = wx.StaticText(self.Panel, wx.ID_ANY, " ", style=wx.ALIGN_LEFT)

        self.CrocoVariableChoice = wx.Choice(self.Panel, wx.ID_ANY, choices=["Croco Variables ..."])
        self.CrocoVariableChoice.SetSelection(0)
        self.CrocoVariableChoice.Bind(wx.EVT_CHOICE, self.onCrocoVariableChoice)

        self.DerivedVariableChoice = wx.Choice(self.Panel, wx.ID_ANY, choices=["Derived Variables ..."])
        self.DerivedVariableChoice.SetSelection(0)
        self.DerivedVariableChoice.Bind(wx.EVT_CHOICE, self.onDerivedVariableChoice)

        self.ResetColorBtn = wx.Button(self.Panel, wx.ID_ANY, "Reset Color")
        self.ResetColorBtn.Bind(wx.EVT_BUTTON, self.onResetColorBtn)
        self.MinColorTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "Min Color", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.MinColorTxt.Bind(wx.EVT_TEXT_ENTER, self.onMinColorTxt)
        self.MaxColorTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "Max Color", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.MaxColorTxt.Bind(wx.EVT_TEXT_ENTER, self.onMaxColorTxt)

        self.LabelTime = wx.StaticText(self.Panel,-1,label="Choose Time",style = wx.ALIGN_CENTER)
        self.LabelMinMaxTime = wx.StaticText(self.Panel, wx.ID_ANY, " ", style=wx.ALIGN_LEFT)
        self.TimeMinusBtn = wx.Button(self.Panel, wx.ID_ANY, "<")
        self.TimeMinusBtn.Bind(wx.EVT_BUTTON, self.onTimeMinusBtn)
        self.TimeTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "Time", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.TimeTxt.Bind(wx.EVT_TEXT_ENTER, self.onTimeTxt)
        self.TimePlusBtn = wx.Button(self.Panel, wx.ID_ANY, ">")
        self.TimePlusBtn.Bind(wx.EVT_BUTTON, self.onTimePlusBtn)

        self.LabelLevel = wx.StaticText(self.Panel,-1,label="Choose level (level>0, depth<=0)",style = wx.ALIGN_CENTER)
        self.LabelMinMaxLevel = wx.StaticText(self.Panel, wx.ID_ANY, " ", style=wx.ALIGN_LEFT)
        self.LabelMinMaxDepth = wx.StaticText(self.Panel, wx.ID_ANY, " ", style=wx.ALIGN_LEFT)
        self.LevelMinusBtn = wx.Button(self.Panel, wx.ID_ANY, "<")
        self.LevelMinusBtn.Bind(wx.EVT_BUTTON, self.onLevelMinusBtn)
        self.LevelTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "Level", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.LevelTxt.Bind(wx.EVT_TEXT_ENTER, self.onLevelTxt)
        self.LevelPlusBtn = wx.Button(self.Panel, wx.ID_ANY, ">")
        self.LevelPlusBtn.Bind(wx.EVT_BUTTON, self.onLevelPlusBtn)

        self.LonSectionBtn = wx.Button(self.Panel, wx.ID_ANY, "Longitude Section")
        self.LonSectionBtn.Bind(wx.EVT_BUTTON, self.onLonSectionBtn)
        self.LonSectionTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "Longitude", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.LonSectionTxt.Bind(wx.EVT_TEXT_ENTER, self.onLonSectionTxt)
        self.LatSectionBtn = wx.Button(self.Panel, wx.ID_ANY, "Latitude Section")
        self.LatSectionBtn.Bind(wx.EVT_BUTTON, self.onLatSectionBtn)
        self.LatSectionTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "Latitude", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.LatSectionTxt.Bind(wx.EVT_TEXT_ENTER, self.onLatSectionTxt)
        # self.HovmullerBtn = wx.Button(self.Panel, wx.ID_ANY, "Hovmuller")
        # self.HovmullerBtn.Bind(wx.EVT_BUTTON, self.onHovmullerBtn)
        self.TimeSeriesBtn = wx.Button(self.Panel, wx.ID_ANY, "Time Series")
        self.TimeSeriesBtn.Bind(wx.EVT_BUTTON, self.onTimeSeriesBtn)
        self.VerticalProfileBtn = wx.Button(self.Panel, wx.ID_ANY, "Vertical Profile")
        self.VerticalProfileBtn.Bind(wx.EVT_BUTTON, self.onVerticalProfileBtn)

        self.PanelCanvas = wx.Panel(self.Panel, -1)
        self.figure = Figure(figsize=(figsize[0],figsize[1]))
        self.canvas = FigureCanvas(self.PanelCanvas, -1, self.figure)

        self.AnimationBtn = wx.Button(self.Panel, wx.ID_ANY, "Animation")
        self.AnimationBtn.Bind(wx.EVT_BUTTON, self.onAnimationBtn)
        self.startTimeTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "1", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.startTimeTxt.Bind(wx.EVT_TEXT_ENTER, self.onstartTimeTxt)
        self.endTimeTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "1", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.endTimeTxt.Bind(wx.EVT_TEXT_ENTER, self.onendTimeTxt)
        self.ZoomInBtn = wx.Button(self.Panel, wx.ID_ANY, "Zoom In")
        self.ZoomInBtn.Bind(wx.EVT_BUTTON, self.onZoomInBtn)
        self.ZoomOutBtn = wx.Button(self.Panel, wx.ID_ANY, "Zoom Out")
        self.ZoomOutBtn.Bind(wx.EVT_BUTTON, self.onZoomOutBtn)
        self.PrintBtn = wx.Button(self.Panel, wx.ID_ANY, "Print")
        self.PrintBtn.Bind(wx.EVT_BUTTON, self.onPrintBtn)

        # self.__set_properties()
        self.__do_layout()

        self.sectionXY = SectionFrame()

        self.currentDirectory = os.getcwd()

    def __do_layout(self):

        topSizer        = wx.BoxSizer(wx.HORIZONTAL)
        leftSizer        = wx.BoxSizer(wx.VERTICAL)
        rightSizer        = wx.BoxSizer(wx.VERTICAL)
        openFileSizer   = wx.BoxSizer(wx.VERTICAL)
        chooseVariablesSizer = wx.BoxSizer(wx.HORIZONTAL)
        colorSizer      = wx.BoxSizer(wx.HORIZONTAL)
        labelTimeSizer  = wx.BoxSizer(wx.HORIZONTAL)
        labelMinMaxTimeSizer  = wx.BoxSizer(wx.HORIZONTAL)
        timeSizer       = wx.BoxSizer(wx.HORIZONTAL)
        labelLevelSizer  = wx.BoxSizer(wx.HORIZONTAL)
        labelMinMaxLevelSizer  = wx.BoxSizer(wx.HORIZONTAL)
        labelMinMaxDepthSizer  = wx.BoxSizer(wx.HORIZONTAL)
        levelSizer       = wx.BoxSizer(wx.HORIZONTAL)
        longitudeSizer  = wx.BoxSizer(wx.HORIZONTAL)
        latitudeSizer   = wx.BoxSizer(wx.HORIZONTAL)
        # hovmullerSizer  = wx.BoxSizer(wx.HORIZONTAL)
        timeSeriesSizer = wx.BoxSizer(wx.HORIZONTAL)
        profileSizer   = wx.BoxSizer(wx.HORIZONTAL)
        canvasSizer     = wx.BoxSizer(wx.VERTICAL)
        buttonsSizer    = wx.BoxSizer(wx.HORIZONTAL)

        openFileSizer.Add(self.OpenFileBtn, 0, wx.ALL, 5)
        openFileSizer.Add(self.OpenFileTxt, 1, wx.ALL|wx.EXPAND, 5)
        chooseVariablesSizer.Add(self.CrocoVariableChoice, 0, wx.ALL, 5)
        chooseVariablesSizer.Add(self.DerivedVariableChoice, 0, wx.ALL, 5)

        colorSizer.Add(self.ResetColorBtn, 0, wx.ALL, 5)
        colorSizer.Add(self.MinColorTxt, 0, wx.ALL, 5)
        colorSizer.Add(self.MaxColorTxt, 0, wx.ALL, 5)

        labelTimeSizer.Add(self.LabelTime, 0, wx.ALL|wx.EXPAND, 5)
        labelMinMaxTimeSizer.Add(self.LabelMinMaxTime, 0, wx.ALL|wx.EXPAND, 5)
        timeSizer.Add(self.TimeMinusBtn, 0, wx.ALL, 5)
        timeSizer.Add(self.TimeTxt, 0, wx.ALL, 5)
        timeSizer.Add(self.TimePlusBtn, 0, wx.ALL, 5)

        labelLevelSizer.Add(self.LabelLevel, 0, wx.ALL|wx.EXPAND, 5)
        labelMinMaxLevelSizer.Add(self.LabelMinMaxLevel, 0, wx.ALL|wx.EXPAND, 5)
        labelMinMaxDepthSizer.Add(self.LabelMinMaxDepth, 0, wx.ALL|wx.EXPAND, 5)
        levelSizer.Add(self.LevelMinusBtn, 0, wx.ALL, 5)
        levelSizer.Add(self.LevelTxt, 0, wx.ALL, 5)
        levelSizer.Add(self.LevelPlusBtn, 0, wx.ALL, 5)

        longitudeSizer.Add(self.LonSectionBtn, 0, wx.ALL, 5)
        longitudeSizer.Add(self.LonSectionTxt, 0, wx.ALL, 5)

        latitudeSizer.Add(self.LatSectionBtn, 0, wx.ALL, 5)
        latitudeSizer.Add(self.LatSectionTxt, 0, wx.ALL, 5)

        # hovmullerSizer.Add(self.HovmullerBtn, 0, wx.ALL, 5)

        timeSeriesSizer.Add(self.TimeSeriesBtn, 0, wx.ALL, 5)

        profileSizer.Add(self.VerticalProfileBtn, 0, wx.ALL, 5)

        canvasSizer.Add(self.PanelCanvas, 1, wx.EXPAND , 5)
        buttonsSizer.Add(self.AnimationBtn,0, wx.ALL, 5)
        buttonsSizer.Add(self.startTimeTxt,1, wx.ALL, 5)
        buttonsSizer.Add(self.endTimeTxt,1, wx.ALL, 5)
        buttonsSizer.Add(self.ZoomInBtn,0, wx.ALL, 5)
        buttonsSizer.Add(self.ZoomOutBtn,0, wx.ALL, 5)
        buttonsSizer.Add(self.PrintBtn,0, wx.ALL, 5)

        leftSizer.Add(openFileSizer, 0,wx.ALL|wx.EXPAND, 5 )
        leftSizer.Add(chooseVariablesSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(labelTimeSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(labelMinMaxTimeSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(timeSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(labelLevelSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(labelMinMaxLevelSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(labelMinMaxDepthSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(levelSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(longitudeSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(latitudeSizer, 0, wx.ALL|wx.EXPAND, 5)
        # leftSizer.Add(hovmullerSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(timeSeriesSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(profileSizer, 0, wx.ALL|wx.EXPAND, 5)
        rightSizer.Add(canvasSizer, 0, wx.EXPAND)
        rightSizer.Add(buttonsSizer, 0, wx.ALL|wx.EXPAND, 5)
        rightSizer.Add(colorSizer, 0, wx.ALL|wx.EXPAND, 5)

        topSizer.Add(leftSizer, 0,wx.ALL|wx.EXPAND, 5 )
        topSizer.Add(rightSizer, 0,wx.EXPAND, 5 )

        self.Panel.SetSizer(topSizer)
        self.Panel.SetAutoLayout(True)
        topSizer.Fit(self)


        self.Layout()


    def onOpenFile(self, event):
        """
        Create and show the Open FileDialog to choose the croco file
        """

        # get path of current script croco_gui.py
        path_script = os.path.dirname(os.path.realpath(__file__))

        # show the dialog box and retrieve the path of the file
        dlg = wx.FileDialog(
            self, message="Choose a file",
            defaultDir=self.currentDirectory, 
            defaultFile="",
            wildcard=wildcard,
            style=wx.FD_OPEN | wx.FD_MULTIPLE | wx.FD_CHANGE_DIR
            )
        if dlg.ShowModal() == wx.ID_OK:
            paths = dlg.GetPaths()
        dlg.Destroy()

        # Create a instance of the Croco class
        self.croco = Croco(paths[0])

        # get path of current script croco_gui.py
        self.croco.path_script = path_script

        # Fill the different parts of the main window from the croco instance
        self.OpenFileTxt.SetLabel(paths[0])       
        self.LabelMinMaxTime.SetLabel("Min/Max Time = "+str(self.croco.times[0])+" ... "+ \
                                      str(self.croco.times[self.croco.crocoGrid.ntimes-1])) 
        self.TimeTxt.SetValue(str(self.croco.times[0]))
        self.timeIndex = 0
        self.time = self.croco.times[0]
        minLevel = 1
        maxLevel = int(self.croco.crocoGrid.N)
        minDepth = - int(self.croco.crocoGrid.h().max())
        maxDepth = 0
        self.LabelMinMaxLevel.SetLabel("Min/Max Level = 1 ... "+ str(maxLevel))
        self.LabelMinMaxDepth.SetLabel("Min/Max Depth = "+ str(minDepth)+" ... "+str(maxDepth))
        self.LevelTxt.SetValue(str(self.croco.crocoGrid.N))
        self.levelIndex=self.croco.crocoGrid.N - 1
        self.startTimeTxt.SetValue(str(self.croco.times[0]))
        self.startTime = self.croco.times[0]
        self.startTimeIndex = 0
        self.endTimeTxt.SetValue(str(self.croco.times[-1]))
        self.endTime = self.croco.times[-1]
        self.endTimeIndex = self.croco.crocoGrid.ntimes -1
        self.CrocoVariableChoice.AppendItems(self.croco.ListOfVariables)
        self.DerivedVariableChoice.AppendItems(self.croco.ListOfDerived)

        self.lonPress = self.croco.crocoGrid.lon()[int(0.5*self.croco.crocoGrid.M),int(0.5*self.croco.crocoGrid.L)]
        self.latPress = self.croco.crocoGrid.lat()[int(0.5*self.croco.crocoGrid.M),int(0.5*self.croco.crocoGrid.L)]
        self.latPressIndex,self.lonPressIndex = self.findLatLonIndex(self.lonPress, self.latPress)
        self.LonSectionTxt.SetValue('%.2F' % self.lonPress)
        self.LatSectionTxt.SetValue('%.2F' % self.latPress)




    def onFigureClick(self,event):
        self.lonPress, self.latPress = event.xdata, event.ydata
        self.latPressIndex,self.lonPressIndex = self.findLatLonIndex(self.lonPress, self.latPress)
        self.LonSectionTxt.SetValue('%.2F' % self.lonPress)
        self.LatSectionTxt.SetValue('%.2F' % self.latPress)

    def onFigureRelease(self,event):
        self.lonRelease, self.latRelease = event.xdata, event.ydata
        self.lonReleaseIndex,self.latReleaseIndex = self.findLatLonIndex(self.lonRelease, self.latRelease)

    def rect_select_callback(self, eclick, erelease):
        ''' Function to select a rectangle when zoom in '''
        self.xPress, self.yPress = eclick.xdata, eclick.ydata
        self.xRelease, self.yRelease = erelease.xdata, erelease.ydata
        self.xlim = [min(self.xPress,self.xRelease),max(self.xPress,self.xRelease)]
        self.ylim = [ min(self.yPress,self.yRelease),max(self.yPress,self.yRelease)]
        self.drawxy(setlim=False)

    def findLatLonIndex(self, lonValue, latValue):
        ''' Find nearest value is an array '''
        a = abs(self.croco.crocoGrid._lon - lonValue) + \
            abs(self.croco.crocoGrid._lat - latValue)
        return np.unravel_index(a.argmin(),a.shape)
        # idx,idy = np.where(np.abs(array-value)==np.abs(array-value).min())

    def onCrocoVariableChoice(self, event):
        self.variableName = self.CrocoVariableChoice.GetString(self.CrocoVariableChoice.GetSelection())
        self.updateVariableXY()

    def onDerivedVariableChoice(self, event):
        self.variableName = self.DerivedVariableChoice.GetString(self.DerivedVariableChoice.GetSelection())
        self.updateVariableXY()

    def onResetColorBtn(self,event):
        self.clim = [np.min(self.variableXY),np.max(self.variableXY)]
        self.MinColorTxt.SetValue('%.2E' % self.clim[0])
        self.MaxColorTxt.SetValue('%.2E' % self.clim[1])
        self.drawxy()

    def onMinColorTxt(self,event):
        self.clim[0] = float(self.MinColorTxt.GetValue())
        self.drawxy(setlim=False)

    def onMaxColorTxt(self,event):
        self.clim[1] = float(self.MaxColorTxt.GetValue())
        self.drawxy(setlim=False)

    def onTimeMinusBtn(self,event):
        self.timeIndex = max(self.timeIndex - 1,0)
        self.time = self.croco.times[self.timeIndex]
        self.TimeTxt.SetValue(str(self.time))
        self.updateVariableXY(setlim=False)

    def onTimePlusBtn(self,event):
        self.timeIndex = min(self.timeIndex + 1,self.croco.crocoGrid.ntimes - 1)
        self.time = self.croco.times[self.timeIndex]
        self.TimeTxt.SetValue(str(self.time))
        self.updateVariableXY(setlim=False)

    def onTimeTxt(self,event):
        time = float(self.TimeTxt.GetValue())
        # find index corresponding to instant time to plot
        self.timeIndex = min( range( len(self.croco.times[:]) ), key=lambda j:abs(time-self.croco.times[j]))
        self.TimeTxt.SetValue(str(self.croco.times[self.timeIndex]))
        self.updateVariableXY(setlim=False)

    def onLevelMinusBtn(self,event):
        self.levelIndex = max(self.levelIndex - 1,0)
        self.LevelTxt.SetValue(str(self.levelIndex + 1))
        self.updateVariableXY(setlim=False)

    def onLevelPlusBtn(self,event):
        self.levelIndex = min(self.levelIndex + 1,self.croco.crocoGrid.N - 1)
        self.LevelTxt.SetValue(str(self.levelIndex + 1))
        self.updateVariableXY(setlim=False)

    def onLevelTxt(self,event):
        depth = float(self.LevelTxt.GetValue())
        if depth > 0:
            self.levelIndex = int(depth)-1
        else:
            zeta = self.croco.read_nc('ssh', indices= "["+str(self.timeIndex)+",:,:]")
            z = self.croco.crocoGrid.scoord2z_r(zeta, alpha=0., beta=0.)
            self.levelIndex = np.argmax(z[:,self.latPressIndex,self.lonPressIndex]>=depth)
        self.updateVariableXY(setlim=False)

    def onLonSectionBtn(self,event):
        try:
            nbdims = len(self.croco.read_var_dim(self.variableName))
        except:
            nbdims = 4                
        if nbdims < 4 :
            print("Not 3D variable")
            return
        self.drawz(typSection="YZ")

    def onLonSectionTxt(self,event):
        try:
            nbdims = len(self.croco.read_var_dim(self.variableName))
        except:
            nbdims = 4                
        if nbdims < 4 :
            print("Not 3D variable")
            return
        self.lonPress = float(self.LonSectionTxt.GetValue())
        self.latPressIndex,self.lonPressIndex = self.findLatLonIndex(self.lonPress, self.latPress) 
        self.drawz(typSection="YZ")

    def onLatSectionBtn(self,event):
        try:
            nbdims = len(self.croco.read_var_dim(self.variableName))
        except:
            nbdims = 4                
        if nbdims < 4 :
            print("Not 3D variable")
            return
        self.drawz(typSection="XZ")

    def onLatSectionTxt(self,event):
        try:
            nbdims = len(self.croco.read_var_dim(self.variableName))
        except:
            nbdims = 4                
        if nbdims < 4 :
            print("Not 3D variable")
            return
        self.latPress = float(self.LatSectionTxt.GetValue())
        self.latPressIndex,self.lonPressIndex = self.findLatLonIndex(self.lonPress, self.latPress) 
        self.drawz(typSection="XZ")

    # def onHovmullerBtn(self,event):
    #     print("Hovmuller")

    def onTimeSeriesBtn(self,event):
        self.getTimeSeries()

    def onVerticalProfileBtn(self,event):
        try:
            nbdims = len(self.croco.read_var_dim(self.variableName))
        except:
            nbdims = 4                
        if nbdims < 4 :
            print("Not 3D variable")
            return

        self.getVertProfile()


    def onAnimationBtn(self,event):
        printDir = self.croco.path_script+"/Figures_" + self.croco.get_run_name()+"/"
        if not os.path.isdir(printDir):
                os.mkdir(printDir)
        filename = printDir+self.title + ".mp4"
        os.system('rm -rf '+filename)
        save_count = self.endTimeIndex - self.startTimeIndex + 1
        anim = animation.FuncAnimation(self.figure, self.animate, \
                   frames = range(self.startTimeIndex,self.endTimeIndex+1), repeat=False, \
                   blit = False, save_count=save_count)
        self.canvas.draw()
        anim.save(filename)

    def animate( self, i):
        ''' function applied at each time step of the animation '''
        self.timeIndex = i
        self.updateVariableXY(setlim=False)

    def onstartTimeTxt(self,event):
        self.startTime = float(self.startTimeTxt.GetValue())
        self.startTimeIndex = min( range( len(self.croco.times[:]) ), key=lambda j:abs(self.startTime-self.croco.times[j]))
        self.startTimeTxt.SetValue(str(self.croco.times[self.startTimeIndex]))

    def onendTimeTxt(self,event):
        self.endTime = float(self.endTimeTxt.GetValue())
        self.endTimeIndex = min( range( len(self.croco.times[:]) ), key=lambda j:abs(self.endTime-self.croco.times[j]))
        self.endTimeTxt.SetValue(str(self.croco.times[self.endTimeIndex]))


    def rect_select_callback(self, eclick, erelease):
        self.xPress, self.yPress = eclick.xdata, eclick.ydata
        self.xRelease, self.yRelease = erelease.xdata, erelease.ydata
        self.xlim = [min(self.xPress,self.xRelease),max(self.xPress,self.xRelease)]
        self.ylim = [ min(self.yPress,self.yRelease),max(self.yPress,self.yRelease)]
        self.drawxy(setlim=False)


    def onZoomInBtn(self,event):
        self.figure.RS.set_active(True)

    def onZoomOutBtn(self,event):
        self.xlim = [np.min(self.croco.crocoGrid._lon),np.max(self.croco.crocoGrid._lon)]
        self.ylim = [np.min(self.croco.crocoGrid._lat),np.max(self.croco.crocoGrid._lat)]
        self.drawxy(setlim=False)

    def onPrintBtn(self,event):
        printDir = self.croco.path_script+"/Figures_" + self.croco.get_run_name()+"/"
        if not os.path.isdir(printDir):
                os.mkdir(printDir)
        filename = printDir+self.title + ".png"
        self.figure.savefig(filename, dpi=self.figure.dpi)

    def updateVariableXY(self,setlim=True):
        ''' Fill the variable self.variableXY with the rigth data'''
        time = str(self.timeIndex)        
        depth = float(self.LevelTxt.GetValue())

        try:
            dims = self.croco.read_var_dim(self.variableName)
        except:
            dims = []                
        if "x_u" in dims:
            mask = self.croco.crocoGrid.umask()
        elif "y_v" in dims:
            mask = self.croco.crocoGrid.vmask()
        else:
            mask = self.croco.crocoGrid.maskr()
        mask = np.where(mask==0.,np.nan,mask)

        # Level plot
        if depth > 0:
            level = str(int(depth)-1)
            if self.variableName in self.croco.ListOfVariables:
                try:
                    self.variableXY = self.croco.read_nc(self.variableName, indices= "["+time+","+level+",:,:]")
                except Exception:
                    try:
                        self.variableXY = self.croco.read_nc(self.variableName, indices= "["+time+",:,:]")
                    except Exception:
                        raise Exception
            elif self.variableName in self.croco.ListOfDerived:
                # depth = float(self.LevelTxt.GetValue())
                # if self.variableName ==  'pv':
                if 'pv' in self.variableName:
                    self.variableXY = self.croco.get_pv(self.timeIndex, depth=depth,typ=self.variableName)
            else:
                print("unknown variable ",self.variableName)
                return
            self.variableXY = mask*self.variableXY

        # depth plot
        elif depth <= 0:
            zeta = self.croco.read_nc('ssh', indices= "["+time+",:,:]")
            z = self.croco.crocoGrid.scoord2z_r(zeta, alpha=0., beta=0.)
            if "x_u" in dims:
                z = self.croco.crocoGrid.rho2u_3d(z)
            elif "y_v" in dims:
                z = self.croco.crocoGrid.rho2v_3d(z)
            minlev,maxlev = self.croco.crocoGrid.zslice(None,self.croco.crocoGrid.maskr(),z,depth,findlev=True)

            # Variable from croco file
            if self.variableName in self.croco.ListOfVariables:      
                indices= "["+time+","+str(minlev)+":"+str(maxlev+1)+",:,:]"    
                var = self.croco.read_nc(self.variableName, indices=indices)
                try:
                    self.variableXY = self.croco.crocoGrid.zslice(var[:,:,:],mask,z[minlev:maxlev+1,:,:],depth)[0]
                    # self.drawxy(setlim=False)
                except:
                    print("Not enough points")
                    pass
            
            # Derived variableXY
            elif self.variableName in self.croco.ListOfDerived:
                # if self.variableName ==  'pv':
                if 'pv' in self.variableName:
                    pv = self.croco.get_pv(self.timeIndex, depth=depth, minlev=minlev, maxlev=maxlev,typ=self.variableName)
                    try:
                        self.variableXY = self.croco.crocoGrid.zslice(pv,mask,z[minlev:maxlev,:,:],depth)[0]
                    except:
                        print("Not enough points")
                        pass

        # Draw the new self.variableXY                
        self.drawxy(setlim=setlim)


    def drawxy(self,setlim=True):
        ''' Draw the current variable self.variableXY in the canvas of the main window '''
        self.figure.clf()

        # Prepare the canvas to receive click events
        self.canvas.mpl_connect('button_press_event', self.onFigureClick)
        self.canvas.mpl_connect('button_release_event', self.onFigureRelease)

        variableXY = ma.masked_invalid(self.variableXY)
        # Set default parameters of the plot if needed
        if setlim:
            self.clim = [np.min(variableXY),np.max(variableXY)]
            self.mincolor = np.min(variableXY)
            self.MinColorTxt.SetValue('%.2E' % self.mincolor)
            self.maxcolor = np.max(variableXY)
            self.MaxColorTxt.SetValue('%.2E' % self.maxcolor)
            self.xlim = [np.min(self.croco.crocoGrid._lon),np.max(self.croco.crocoGrid._lon)]
            self.ylim = [np.min(self.croco.crocoGrid._lat),np.max(self.croco.crocoGrid._lat)]

        depth = float(self.LevelTxt.GetValue())
        # Level pyplot
        if depth > 0:
            self.title = "{:s}, Level={:4d}, Time={:4.1f}".format(self.variableName,self.levelIndex+1,self.croco.times[self.timeIndex])
        # Depth plot
        else:
            self.title = "{:s}, Depth={:4.1f}, Time={:4.1f}".format(self.variableName,depth,self.croco.times[self.timeIndex])
        mypcolor(self,self.croco.crocoGrid._lon,self.croco.crocoGrid._lat,variableXY,\
                      title=self.title,\
                      xlabel='Longitude',\
                      ylabel='Latitude',\
                      xlim=self.xlim,\
                      ylim=self.ylim,\
                      clim=self.clim)
        
        self.canvas.draw()
        self.canvas.Refresh()
        self.Refresh()

    def drawz(self,typSection=None):
        ''' Create a section window if needed and prepare the of the plot the section '''
        time = str(self.timeIndex)
        lon = str(self.lonPressIndex)
        lat = str(self.latPressIndex)
        zeta = self.croco.read_nc('ssh', indices= "["+time+",:,:]")

        if typSection == "XZ":
            # Create the window if needed
            try:
                self.sectionXZ.IsShown()
            except:
                self.sectionXZ = SectionFrame(typSection="XZ", croco=self.croco)
            section = self.sectionXZ
            section.section = "Latitude"
            section.xlabel = "Longitude"        
            section.latlon = self.latPress
            section.latlonIndex = self.latPressIndex
            section.x = repmat(self.croco.crocoGrid._lon[self.latPressIndex,:].squeeze(),self.croco.crocoGrid.N,1)
            section.y = self.croco.crocoGrid.scoord2z_r(zeta, alpha=0., beta=0)[:,self.latPressIndex,:]
            # Variable from croco file
            if self.variableName in self.croco.ListOfVariables:   
                section.variableZ = self.croco.read_nc(self.variableName, indices= "["+time+",:,"+lat+",:]")
            # Derived Variable
            elif self.variableName in self.croco.ListOfDerived:
                if 'pv' in self.variableName:
                    pv = self.croco.get_pv(self.timeIndex, minlev=0, maxlev=self.croco.crocoGrid.N-1,typ=self.variableName)
                    section.variableZ = pv[:,self.latPressIndex,:]

        elif typSection == "YZ":
            # Create the window if needed
            try:
                self.sectionYZ.IsShown()
            except:
                self.sectionYZ = SectionFrame(typSection="YZ", croco=self.croco)
            section = self.sectionYZ
            section.section = "Longitude"
            section.xlabel = "Latitude"
            section.latlon = self.lonPress
            section.latlonIndex = self.lonPressIndex        
            section.x = repmat(self.croco.crocoGrid._lat[:,self.lonPressIndex].squeeze(),self.croco.crocoGrid.N,1)
            section.y = self.croco.crocoGrid.scoord2z_r(zeta, alpha=0., beta=0)[:,:,self.lonPressIndex]
            # Variable from croco file
            if self.variableName in self.croco.ListOfVariables:   
                section.variableZ = self.croco.read_nc(self.variableName, indices= "["+time+",:,:,"+lon+"]")
            # Derived Variable
            elif self.variableName in self.croco.ListOfDerived:
                # if self.variableName ==  'pv':
                if 'pv' in self.variableName:
                    pv = self.croco.get_pv(self.timeIndex, minlev=0, maxlev=self.croco.crocoGrid.N-1,typ=self.variableName)
                    section.variableZ = pv[:,:,self.lonPressIndex]
        else:
            print("drawz: unknown type section: ",typSection)
            return

        section.variableName = self.variableName
        section.time = self.croco.times[self.timeIndex]
        section.timeIndex = self.timeIndex
        section.startTimeTxt.SetValue(str(self.croco.times[0]))
        section.startTime = self.croco.times[0]
        section.startTimeIndex = 0
        section.endTimeTxt.SetValue(str(self.croco.times[-1]))
        section.endTime = self.croco.times[-1]
        section.endTimeIndex = self.croco.crocoGrid.ntimes -1
        section.drawz()

    def getTimeSeries(self,profTyp=None):
        ''' Fill the profile variable of the time series'''
        lat = str(self.latPressIndex)
        lon = str(self.lonPressIndex)
        # timestr = str(self.timeIndex)
        depth = float(self.LevelTxt.GetValue())

        # Create window for time series is needed
        try:
            self.profileFrame.IsShown()
        except Exception:           
            self.profileFrame = ProfileFrame(self.croco)

        try:
            dims = self.croco.read_var_dim(self.variableName)
        except:
            dims=[]
        if "x_u" in dims:
            mask = self.croco.crocoGrid.umask()
        elif "y_v" in dims:
            mask = self.croco.crocoGrid.vmask()
        else:
            mask = self.croco.crocoGrid.maskr()

        # Time series on one level    
        if depth > 0:
            if self.variableName in self.croco.ListOfVariables:
                level = str(int(depth)-1) 
                print("getTimeSeries: indices=", "[:,"+level+","+lat+","+lon+"]")
                profile = self.croco.read_nc(self.variableName, indices= "[:,"+level+","+lat+","+lon+"]")

            elif self.variableName in self.croco.ListOfDerived:
                level = int(depth)
                profile = np.zeros_like(self.croco.times)
                for it in range(len(self.croco.times)):
                    # if self.variableName ==  'pv':
                    if 'pv' in self.variableName:
                        profile[it] = self.croco.get_pv(it, depth=level,typ=self.variableName)[self.latPressIndex,self.lonPressIndex]

            else:
                print("unknown variable ",self.variableName)
                return
            title="{:s}, Lon={:4.1f}, Lat={:4.1f}, level={:4.1f}".\
                format(self.variableName,self.lonPress,self.latPress,self.levelIndex+1)

        # Time series on one depth    
        elif depth <= 0:
            profile = np.zeros_like(self.croco.times)
            # for each time step
            for it in range(len(self.croco.times)):
                # Calculate z
                zeta = self.croco.read_nc('ssh', indices= "["+str(it)+",:,:]")
                z = self.croco.crocoGrid.scoord2z_r(zeta, alpha=0., beta=0.)
                if "x_u" in dims:
                    z = self.croco.crocoGrid.rho2u_3d(z)
                elif "y_v" in dims:
                    z = self.croco.crocoGrid.rho2v_3d(z)


                if self.variableName in self.croco.ListOfVariables:    
                    # Find level araound depth
                    maxlev = np.argmax(z[:,self.latPressIndex,self.lonPressIndex]>=depth)
                    minlev = maxlev-1  
                    z1 = z[minlev,self.latPressIndex,self.lonPressIndex]
                    z2 = z[maxlev,self.latPressIndex,self.lonPressIndex]
                    # read variable and do interpolation
                    indices= "["+str(it)+","+str(minlev)+":"+str(maxlev+1)+","+lat+","+lon+"]"
                    var = self.croco.read_nc(self.variableName, indices=indices)
                    profile[it]=((var[0]-var[1])*depth+var[1]*z1-var[0]*z2)/(z1-z2) * \
                                mask[self.latPressIndex,self.lonPressIndex]
            
                elif self.variableName in self.croco.ListOfDerived:
                    minlev,maxlev = self.croco.crocoGrid.zslice(None,mask,z,depth,findlev=True)
                    # if self.variableName ==  'pv':
                    if 'pv' in self.variableName:
                        pv = self.croco.get_pv(it, depth=depth, minlev=minlev, maxlev=maxlev,typ=self.variableName)
                        try:
                            pvz = self.croco.crocoGrid.zslice(pv,mask,z[minlev:maxlev,:,:],depth)[0]
                        except:
                            print("Not enough points")
                            pass
                    profile[it]=pvz[self.latPressIndex,self.lonPressIndex]


            title="{:s}, Lon={:4.1f}, Lat={:4.1f}, depth={:4.1f}".\
                format(self.variableName,self.lonPress,self.latPress,depth)


        # draw curve
        self.profileFrame.drawCurv(profile,title=title)


    def getVertProfile(self):
        ''' Fill the profile variable for the vertical profile'''
        time = str(self.timeIndex)
        lat = str(self.latPressIndex)
        lon = str(self.lonPressIndex)
        title="{:s}, Lon={:4.1f}, Lat={:4.1f}, Time={:4.1f}".\
            format(self.variableName,self.lonPress,self.latPress,\
            self.croco.times[self.timeIndex])
        zeta = self.croco.read_nc('ssh', indices= "["+time+",:,:]")
        z = self.croco.crocoGrid._scoord2z('r', zeta, alpha=0., beta=0)[0][:,self.latPressIndex,self.lonPressIndex]
        
        if self.variableName in self.croco.ListOfVariables: 
            profile = self.croco.read_nc(self.variableName, indices= "["+time+",:,"+lat+","+lon+"]")

        elif self.variableName in self.croco.ListOfDerived:
            # if self.variableName ==  'pv':
            if 'pv' in self.variableName:
                profile = np.full_like(z, np.nan)
                pv = self.croco.get_pv(self.timeIndex, minlev=0, maxlev=self.croco.crocoGrid.N-1,typ=self.variableName)
                profile[1:] = pv[:,self.latPressIndex,self.lonPressIndex]
        else:
            print("unknown variable ",self.variableName)
            return
        try:
            self.profileFrame.IsShown()
        except:
            self.profileFrame = ProfileFrame(self.croco)
        self.profileFrame.drawCurv(profile=profile,z=z,title=title,ylabel="depth")

# end of class CrocoGui



# Run the program
if __name__ == "__main__":
    app = wx.App(False)
    frame = CrocoGui()
    frame.Show()
    app.MainLoop()
